{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"pytket-custatevec","text":"<p>GPU-accelerated statevector simulation for pytket.</p> <p><code>pytket-custatevec</code> acts as a bridge between Quantinuum's pytket compiler and NVIDIA's cuQuantum SDK, enabling massive speedups for statevector simulations.</p>"},{"location":"#why-use-this-backend","title":"Why use this backend?","text":"<ul> <li> <p> High Performance     ---     Leverage NVIDIA GPUs to simulate quantum circuits significantly faster than CPU-based simulators, especially for entangling gates.</p> </li> <li> <p> Seamless Integration     ---     Works as a standard <code>pytket</code> Backend. Just switch your backend import, and your existing code runs on the GPU immediately.</p> </li> <li> <p> Optimized Memory     ---     Utilizes <code>cuStateVec</code>'s advanced memory management to handle large statevectors efficiently on GPU VRAM.</p> </li> <li> <p> Gate Support     ---     Supports the full range of standard gates, automatic implicit swaps, and complex measurement scenarios.</p> </li> </ul>"},{"location":"#architecture","title":"Architecture","text":"<p>This library sits directly on top of the NVIDIA cuQuantum stack.</p> <pre><code>graph LR\n    User[User Code] --&gt;|pytket Circuit| Backend[CuStateVecBackend]\n    Backend --&gt;|cuQuantum Python| SDK[NVIDIA cuStateVec]\n    SDK --&gt;|CUDA| GPU[NVIDIA GPU]\n\n    style User fill:#f9f9f9,stroke:#333,stroke-width:2px\n    style Backend fill:#e1f5fe,stroke:#0277bd,stroke-width:2px\n    style SDK fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px\n    style GPU fill:#212121,stroke:#000,stroke-width:2px,color:#fff</code></pre>"},{"location":"#quick-links","title":"Quick Links","text":"<p>Not sure where to start?</p> <ul> <li> <p>Get Started     ---     Install the package and set up CUDA.</p> <p> Installation</p> </li> <li> <p>See Examples     ---     Run your first simulation or expectation value.</p> <p> View Examples</p> </li> <li> <p>API Reference     ---     Deep dive into the Backend classes.</p> <p> Read API</p> </li> </ul>"},{"location":"#bugs-and-support","title":"Bugs and Support","text":"<p>Please file bugs and feature requests on the GitHub Issue Tracker.</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#development","title":"Development","text":"<p>To install an extension in editable mode, from its root folder run:</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Pull requests are welcome. To make a PR, first fork the repo, make your proposed changes on the <code>main</code> branch, and open a PR from your fork. If it passes tests and is accepted after review, it will be merged in.</p>"},{"location":"contributing/#code-style","title":"Code style","text":"<p>Code style can be checked locally using pre-commit hooks; run pre-commit before committing your changes and opening a pull request by executing:</p> <pre><code>pre-commit run\n</code></pre> <p>This will automatically: * Format code using ruff with default options. * Do static type checking using mypy. * Lint using ruff to check compliance with a set of style requirements (listed in <code>ruff.toml</code>).</p> <p>Compliance with the above checks is checked by continuous integration before a pull request can be merged.</p>"},{"location":"contributing/#docstrings","title":"Docstrings","text":"<p>We use the Google style docstrings, please see this page for reference.</p>"},{"location":"contributing/#tests","title":"Tests","text":"<p>To run the tests for a module:</p> <pre><code>pip install \"pytket-custatevec[test]\"\npytest tests/\n</code></pre> <p>When adding a new feature, please add a test for it. When fixing a bug, please add a test that demonstrates the fix.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<p>In order to use it, you need access to a Linux machine (or WSL) with an NVIDIA GPU of Compute Capability +7.0 (check it here) and have <code>cuda-toolkit</code> installed.</p> <pre><code>sudo apt install cuda-toolkit\n</code></pre>"},{"location":"installation/#installation","title":"Installation","text":"<p>Prerequisites</p> <p>Before installing, ensure you have an NVIDIA GPU (Compute Capability +7.0) and <code>cuda-toolkit</code> installed.</p> <p>You can install the dependencies and the package using your preferred package manager.</p> Conda (Recommended)Pip <p>We recommend Conda to handle CUDA dependencies automatically.</p> <pre><code>conda install -c conda-forge cuquantum-python\npip install pytket-custatevec\n</code></pre> <p>If you use pure pip, you must manage CUDA libraries manually.</p> <pre><code>pip install pytket-custatevec\n</code></pre> <p>CUDA Version Matching</p> <p>Ensure your <code>cupy</code> and <code>cuquantum</code> versions match your installed CUDA Toolkit version. Read the official guide here.</p>"},{"location":"people/","title":"People","text":"<p><code>pytket-custatevec</code> is developed and maintained by the Quantinuum team and our amazing community of contributors.</p>"},{"location":"people/#maintainers","title":"Maintainers","text":"<p>The current maintainers of the <code>pytket-custatevec</code> repository.</p> @Fabian Finger @Gabriel Matos @Pranav Kalidindi"},{"location":"people/#acknowledgments","title":"Acknowledgments","text":"<p>Special thanks to the NVIDIA cuQuantum team for their support and the underlying library that makes this backend possible.</p> <p>Contribute</p> <p>Want to see your face here? We welcome contributions! Check out our Contributing Guidelines to get started.</p>"},{"location":"api/","title":"API Reference","text":"<p>The <code>pytket-custatevec</code> package provides high-performance GPU backends for simulating quantum circuits.</p>"},{"location":"api/#available-backends","title":"Available Backends","text":"<ul> <li> <p> Statevector Backend     ---     Calculates the exact quantum state vector (\\(2^n\\) amplitudes). Ideal for theoretical validation and calculating exact expectation values.</p> <p> Read Docs</p> </li> <li> <p> Shots Backend     ---     Simulates measurement sampling (shots). Use this to mimic the behavior of a real QPU or to test probabilistic algorithms.</p> <p> Read Docs</p> </li> </ul>"},{"location":"api/#comparison","title":"Comparison","text":"<p>Not sure which backend to use?</p> Feature <code>CuStateVecStateBackend</code> <code>CuStateVecShotsBackend</code> Output Full Statevector (<code>np.ndarray</code>) Measurement Counts (<code>dict</code>) Memory Usage High (scales exponentially \\(2^n\\)) High (internal statevector) Primary Use Debugging, Exact Expectations Sampling, QPU Emulation Basis Order Supports ILO &amp; DLO Supports ILO &amp; DLO Noise Ideal (Noise-free) Shot Noise (Sampling error)"},{"location":"api/#common-functionality","title":"Common Functionality","text":"<p>Both backends inherit from the <code>pytket</code> <code>Backend</code> class and support:</p> <ul> <li>Compilation: <code>get_compiled_circuit(circ)</code> handles implicit swaps and gate decomposition automatically.</li> <li>GPU Acceleration: Both utilize NVIDIA cuStateVec to accelerate tensor operations.</li> <li>Context Management: Both handle GPU memory resources efficiently.</li> </ul> <p>Performance Note</p> <p>For circuits with more than 30 qubits, ensure your GPU has sufficient VRAM. The statevector size doubles with every additional qubit.</p>"},{"location":"api/shots_backend/","title":"Shots Backend","text":""},{"location":"api/shots_backend/#pytket.extensions.custatevec.backends.CuStateVecShotsBackend","title":"<code>CuStateVecShotsBackend()</code>","text":"<p>A pytket Backend using <code>GeneralState</code> to obtain shots.</p> <p>Constructs a new cuStateVec backend object.</p> Source code in <code>pytket/extensions/custatevec/backends/custatevec_backend.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Constructs a new cuStateVec backend object.\"\"\"\n    super().__init__()\n</code></pre>"},{"location":"api/shots_backend/#pytket.extensions.custatevec.backends.CuStateVecShotsBackend.backend_info","title":"<code>backend_info</code>  <code>property</code>","text":"<p>Returns information on the backend.</p>"},{"location":"api/shots_backend/#pytket.extensions.custatevec.backends.CuStateVecShotsBackend.process_circuit","title":"<code>process_circuit(circuit, n_shots=None, valid_check=True, **kwargs)</code>","text":"<p>Submits circuits to the backend for running.</p> Source code in <code>pytket/extensions/custatevec/backends/custatevec_backend.py</code> <pre><code>def process_circuit(\n    self,\n    circuit: Circuit,\n    n_shots: int | None = None,\n    valid_check: bool = True,\n    **kwargs: KwargTypes,\n) -&gt; ResultHandle:\n    \"\"\"Submits circuits to the backend for running.\"\"\"\n    return self.process_circuits(\n        [circuit],\n        n_shots=n_shots,\n        valid_check=valid_check,\n        **kwargs,\n    )[0]\n</code></pre>"},{"location":"api/shots_backend/#pytket.extensions.custatevec.backends.CuStateVecShotsBackend.process_circuits","title":"<code>process_circuits(circuits, n_shots=None, valid_check=True, **kwargs)</code>","text":"<p>Submits circuits to the backend for running and returns result handles.</p> <p>Parameters:</p> Name Type Description Default <code>circuits</code> <code>Sequence[Circuit]</code> <p>List of circuits to be submitted.</p> required <code>n_shots</code> <code>int | Sequence[int] | None</code> <p>Number of shots for shot-based calculation.</p> <code>None</code> <code>seed</code> <p>Seed for random number generation.</p> required <code>valid_check</code> <code>bool</code> <p>Whether to check for circuit correctness.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[ResultHandle]</code> <p>List of result handles for the submitted circuits.</p> Source code in <code>pytket/extensions/custatevec/backends/custatevec_backend.py</code> <pre><code>def process_circuits(  # noqa: D417\n    self,\n    circuits: Sequence[Circuit],\n    n_shots: int | Sequence[int] | None = None,\n    valid_check: bool = True,\n    **kwargs: KwargTypes,\n) -&gt; list[ResultHandle]:\n    \"\"\"Submits circuits to the backend for running and returns result handles.\n\n    Args:\n        circuits: List of circuits to be submitted.\n        n_shots: Number of shots for shot-based calculation.\n        seed: Seed for random number generation.\n        valid_check: Whether to check for circuit correctness.\n\n    Returns:\n        List of result handles for the submitted circuits.\n    \"\"\"\n    if n_shots is None:\n        raise ValueError(\"n_shots must be specified for shot-based simulation.\")\n\n    all_shots = [n_shots] * len(circuits) if isinstance(n_shots, int) else n_shots\n\n    if valid_check:\n        self._check_all_circuits(circuits, nomeasure_warn=False)\n\n    handle_list = []\n    for circuit, circ_shots in zip(circuits, all_shots, strict=False):\n        with CuStateVecHandle() as libhandle:\n            sv = initial_statevector(\n                handle=libhandle,\n                n_qubits=circuit.n_qubits,\n                sv_type=\"zero\",\n                dtype=cudaDataType.CUDA_C_64F,\n            )\n            run_circuit(libhandle, circuit, sv)\n\n            # IMPORTANT: _qubit_idx_map matches cuStateVec's little-endian convention\n            # (qubit 0 = least significant) with pytket's big-endian (qubit 0 = most significant).\n            # Now all operations by the cuStateVec library will be in the correct order.\n            _qubit_idx_map: dict[Qubit, int] = {q: i for i, q in enumerate(sorted(circuit.qubits, reverse=True))}\n            # Get relabeled qubit indices that will be measured\n            measured_qubits = [_qubit_idx_map[x] for x in circuit.qubit_readout]\n            # IMPORTANT: After relabling with _qubit_idx_map, cuStateVec.sampler_sample function still\n            # requires its list of measured qubits to be in the LSB-to-MSB order.\n            # This reversal adapts our MSB-first list to the LSB-first format cuStateVec requires.\n            measured_qubits.reverse()\n\n            sampler_descriptor, size_t = cusv.sampler_create(  # type: ignore[no-untyped-call]\n                handle=libhandle.handle,\n                sv=sv.array.data.ptr,\n                sv_data_type=cudaDataType.CUDA_C_64F,\n                n_index_bits=sv.n_qubits,\n                n_max_shots=circ_shots,\n            )\n\n            bit_strings_int64 = np.empty((circ_shots, 1), dtype=np.int64)  # needs to be int64\n\n            # Generate random numbers for sampling\n            seed = kwargs.get(\"seed\")\n            rng = np.random.default_rng(seed)\n            randnums = np.atleast_1d(rng.random(circ_shots, dtype=np.float64)).tolist()\n\n            cusv.sampler_preprocess(  # type: ignore[no-untyped-call]\n                handle=libhandle.handle,\n                sampler=sampler_descriptor,\n                extra_workspace=0,\n                extra_workspace_size_in_bytes=0,\n            )\n\n            cusv.sampler_sample(  # type: ignore[no-untyped-call]\n                handle=libhandle.handle,\n                sampler=sampler_descriptor,\n                bit_strings=bit_strings_int64.ctypes.data,\n                bit_ordering=measured_qubits,\n                bit_string_len=len(measured_qubits),\n                randnums=randnums,\n                n_shots=n_shots,\n                output=SamplerOutput.RANDNUM_ORDER,\n            )\n\n            cusv.sampler_destroy(sampler_descriptor)  # type: ignore[no-untyped-call]\n\n        handle = ResultHandle(str(uuid4()))\n\n        # Reformat bit_strings from list of 64-bit signed integer (memory-efficient\n        # way for custatevec to save many shots) to list of binaries for OutcomeArray\n        bit_strings_binary = [format(s, f\"0{len(measured_qubits)}b\") for s in bit_strings_int64.flatten().tolist()]\n        bit_strings_binary = [tuple(map(int, binary)) for binary in bit_strings_binary]  # type: ignore[misc]\n\n        # In order to be able to use the BackendResult functionality,\n        # we only pass the array of the statevector to BackendResult\n        self._cache[handle] = {\n            \"result\": BackendResult(\n                state=cp.asnumpy(sv.array),\n                shots=OutcomeArray.from_readouts(bit_strings_binary),\n            ),\n        }\n        handle_list.append(handle)\n    return handle_list\n</code></pre>"},{"location":"api/state_backend/","title":"Statevector Backend","text":""},{"location":"api/state_backend/#pytket.extensions.custatevec.backends.CuStateVecStateBackend","title":"<code>CuStateVecStateBackend()</code>","text":"<p>A pytket Backend using <code>GeneralState</code> to obtain state vectors.</p> <p>Constructs a new cuStateVec backend object.</p> Source code in <code>pytket/extensions/custatevec/backends/custatevec_backend.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Constructs a new cuStateVec backend object.\"\"\"\n    super().__init__()\n</code></pre>"},{"location":"api/state_backend/#pytket.extensions.custatevec.backends.CuStateVecStateBackend.backend_info","title":"<code>backend_info</code>  <code>property</code>","text":"<p>Returns information on the backend.</p>"},{"location":"api/state_backend/#pytket.extensions.custatevec.backends.CuStateVecStateBackend.get_operator_expectation_value","title":"<code>get_operator_expectation_value(circuit, operator)</code>","text":"<p>Calculate the expectation value of a QubitPauliOperator given a quantum state prepared by a circuit.</p> <p>This method computes the expectation value of a specified operator with respect to the quantum state generated by the provided state preparation circuit. It leverages cuStateVec for efficient statevector simulation and expectation value computation.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>Circuit</code> <p>The quantum circuit that prepares the desired quantum state.</p> required <code>operator</code> <code>QubitPauliOperator</code> <p>The operator for which the expectation value is to be calculated.</p> required <p>Returns:</p> Type Description <code>float64</code> <p>np.float64: The computed expectation value of the operator with respect to</p> <code>float64</code> <p>the quantum state.</p> Source code in <code>pytket/extensions/custatevec/backends/custatevec_backend.py</code> <pre><code>def get_operator_expectation_value(\n    self,\n    circuit: Circuit,\n    operator: QubitPauliOperator,\n) -&gt; np.float64:\n    \"\"\"Calculate the expectation value of a QubitPauliOperator given a quantum state prepared by a circuit.\n\n    This method computes the expectation value of a specified operator with respect\n    to the quantum state generated by the provided state preparation circuit. It\n    leverages cuStateVec for efficient statevector simulation and expectation value\n    computation.\n\n    Args:\n        circuit (Circuit): The quantum circuit that prepares the desired\n            quantum state.\n        operator (QubitPauliOperator): The operator for which the expectation value\n            is to be calculated.\n\n    Returns:\n        np.float64: The computed expectation value of the operator with respect to\n        the quantum state.\n    \"\"\"\n    with CuStateVecHandle() as libhandle:\n        sv = initial_statevector(\n            handle=libhandle,\n            n_qubits=circuit.n_qubits,\n            sv_type=\"zero\",\n            dtype=cudaDataType.CUDA_C_64F,\n        )\n        run_circuit(libhandle, circuit, sv)\n        return compute_expectation(libhandle, sv, operator, circuit)\n</code></pre>"},{"location":"api/state_backend/#pytket.extensions.custatevec.backends.CuStateVecStateBackend.process_circuit","title":"<code>process_circuit(circuit, n_shots=None, valid_check=True, **kwargs)</code>","text":"<p>Submits circuits to the backend for running.</p> Source code in <code>pytket/extensions/custatevec/backends/custatevec_backend.py</code> <pre><code>def process_circuit(\n    self,\n    circuit: Circuit,\n    n_shots: int | None = None,\n    valid_check: bool = True,\n    **kwargs: KwargTypes,\n) -&gt; ResultHandle:\n    \"\"\"Submits circuits to the backend for running.\"\"\"\n    return self.process_circuits(\n        [circuit],\n        n_shots=n_shots,\n        valid_check=valid_check,\n        **kwargs,\n    )[0]\n</code></pre>"},{"location":"api/state_backend/#pytket.extensions.custatevec.backends.CuStateVecStateBackend.process_circuits","title":"<code>process_circuits(circuits, n_shots=None, valid_check=True, **kwargs)</code>","text":"<p>Submits circuits to the backend for running.</p> <p>The results will be stored in the backend's result cache to be retrieved by the corresponding get_ method. <p>Parameters:</p> Name Type Description Default <code>circuits</code> <code>Sequence[Circuit]</code> <p>List of circuits to be submitted.</p> required <code>n_shots</code> <code>int | Sequence[int] | None</code> <p>Number of shots in case of shot-based calculation. This is unused, since this backend does not support shots.</p> <code>None</code> <code>seed</code> <p>Seed for random number generation. This is unused, since this backend does not support shots.</p> required <code>valid_check</code> <code>bool</code> <p>Whether to check for circuit correctness.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[ResultHandle]</code> <p>Results handle objects.</p> Source code in <code>pytket/extensions/custatevec/backends/custatevec_backend.py</code> <pre><code>def process_circuits(  # noqa: D417\n    self,\n    circuits: Sequence[Circuit],\n    n_shots: int | Sequence[int] | None = None,  # noqa: ARG002\n    valid_check: bool = True,\n    **kwargs: KwargTypes,  # noqa: ARG002\n) -&gt; list[ResultHandle]:\n    \"\"\"Submits circuits to the backend for running.\n\n    The results will be stored in the backend's result cache to be retrieved by the\n    corresponding get_&lt;data&gt; method.\n\n    Args:\n        circuits: List of circuits to be submitted.\n        n_shots: Number of shots in case of shot-based calculation.\n            This is unused, since this backend does not support shots.\n        seed: Seed for random number generation.\n            This is unused, since this backend does not support shots.\n        valid_check: Whether to check for circuit correctness.\n\n    Returns:\n        Results handle objects.\n    \"\"\"\n    if valid_check:\n        self._check_all_circuits(circuits, nomeasure_warn=False)\n\n    handle_list = []\n    for circuit in circuits:\n        with CuStateVecHandle() as libhandle:\n            sv = initial_statevector(\n                handle=libhandle,\n                n_qubits=circuit.n_qubits,\n                sv_type=\"zero\",\n                dtype=cudaDataType.CUDA_C_64F,\n            )\n            run_circuit(libhandle, circuit, sv)\n        handle = ResultHandle(str(uuid4()))\n        # In order to be able to use the BackendResult functionality,\n        # we only pass the array of the statevector to BackendResult\n        self._cache[handle] = {\"result\": BackendResult(state=cp.asnumpy(sv.array))}\n        handle_list.append(handle)\n    return handle_list\n</code></pre>"},{"location":"examples/","title":"Examples Overview","text":"<p>Explore common usage patterns for <code>pytket-custatevec</code>.</p> <ul> <li> <p> Basic Simulation     ---     Learn how to run statevector simulations and shot-based sampling.</p> <p> Read More</p> </li> <li> <p> Advanced Usage     ---     Calculate expectation values efficiently and handle specific basis ordering.</p> <p> Read More</p> </li> </ul>"},{"location":"examples/advanced/","title":"Basis Order","text":"<p>By default, pytket uses ilo (Increasing Lexicographic Order). You can explicitly request dlo (Decreasing Lexicographic Order/Big Endian).</p> <pre><code>from pytket import Circuit, BasisOrder\nfrom pytket.extensions.custatevec import CuStateVecStateBackend\n\n# Create state |01&gt; (qubit 0 is 0, qubit 1 is 1)\ncirc = Circuit(2).X(1) \n\nbackend = CuStateVecStateBackend()\ncompiled_circ = backend.get_compiled_circuit(circ)\nresult = backend.run_circuit(compiled_circ)\n\n# pytket default (Little Endian): |01&gt; corresponds to index 2 (binary 10 reversed)\nprint(\"ILO (Default):\", result.get_state(basis=BasisOrder.ilo))\n\n# Big Endian: |01&gt; corresponds to index 1 (binary 01)\nprint(\"DLO:\", result.get_state(basis=BasisOrder.dlo))\n</code></pre>"},{"location":"examples/simulation/","title":"Simulation Examples","text":""},{"location":"examples/simulation/#statevector-simulation","title":"Statevector Simulation","text":"<p>The <code>CuStateVecStateBackend</code> allows you to retrieve the full statevector of a quantum circuit. This example simulates a Bell State (\\(|\\Phi^+\\rangle = \\frac{|00\\rangle + |11\\rangle}{\\sqrt{2}}\\)).</p> <pre><code>import numpy as np\nfrom pytket import Circuit\nfrom pytket.extensions.custatevec import CuStateVecStateBackend\n\n# 1. Define a Bell State circuit\ncirc = Circuit(2)\ncirc.H(0).CX(0, 1)\n\n# 2. Initialize the Statevector Backend\nbackend = CuStateVecStateBackend()\n\n# 3. Compile the circuit for the backend\ncompiled_circ = backend.get_compiled_circuit(circ)\n\n# 4. Run and retrieve the statevector\nhandle = backend.process_circuit(compiled_circ)\nresult = backend.get_result(handle)\nstatevector = result.get_state()\n\nprint(\"Statevector:\", np.round(statevector, 3))\n</code></pre>"},{"location":"examples/simulation/#shot-based-sampling","title":"Shot-based Sampling","text":"<p>The CuStateVecShotsBackend mimics a quantum computer by returning measurement counts.</p> <pre><code>from pytket import Circuit\nfrom pytket.extensions.custatevec import CuStateVecShotsBackend\n\n# 1. Define a circuit with measurements\ncirc = Circuit(2, 2)\ncirc.H(0).CX(0, 1)\ncirc.measure_all()\n\n# 2. Initialize the Shots Backend\nbackend = CuStateVecShotsBackend()\ncompiled_circ = backend.get_compiled_circuit(circ)\n\n# 3. Run with a specific number of shots\nhandle = backend.process_circuit(compiled_circ, n_shots=1000)\nresult = backend.get_result(handle)\n\n# 4. Get counts\ncounts = result.get_counts()\nprint(\"Counts:\", counts)\n</code></pre>"},{"location":"examples/simulation/#calculating-expectation-values","title":"Calculating Expectation Values","text":"<p>You can calculate operator expectation values efficiently on the GPU without explicitly retrieving the full statevector.</p> <pre><code>from pytket import Circuit, Qubit\nfrom pytket.pauli import Pauli, QubitPauliString\nfrom pytket.utils.operators import QubitPauliOperator\nfrom pytket.utils.expectations import get_operator_expectation_value\nfrom pytket.extensions.custatevec import CuStateVecStateBackend\n\n# 1. Define a circuit\ncirc = Circuit(2)\ncirc.H(0).CX(0, 1)  # Bell state\n\n# 2. Define an operator (e.g., Z0 * Z1)\nop = QubitPauliOperator({\n    QubitPauliString([Qubit(0), Qubit(1)], [Pauli.Z, Pauli.Z]): 1.0\n})\n\n# 3. Calculate expectation value\nbackend = CuStateVecStateBackend()\nexpectation = get_operator_expectation_value(circ, op, backend)\n\nprint(f\"Expectation value &lt;Z0 Z1&gt;: {expectation}\")\n</code></pre>"}]}